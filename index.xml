<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Valentin Manès</title>
    <link>/</link>
      <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <description>Valentin Manès</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Tue, 26 May 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/img/profile.jpg</url>
      <title>Valentin Manès</title>
      <link>/</link>
    </image>
    
    <item>
      <title>Boosting Fuzzer Efficiency: An Information Theoretic Perspective</title>
      <link>/publication/entropic/</link>
      <pubDate>Tue, 26 May 2020 00:00:00 +0000</pubDate>
      <guid>/publication/entropic/</guid>
      <description>&lt;p&gt;In this paper, we take the fundamental perspective of fuzzing as a learning
process. Suppose before fuzzing, we know nothing about the behaviors of a
program P: What does it do? Executing the first test input, we learn how P
behaves for this input. Executing the next input, we either observe the same
or discover a new behavior. As such, each execution reveals “some amount” of
information about P’s behaviors. A classic measure of information is
Shannon’s entropy. Measuring entropy allows us to quantify how much is
learned from each generated test input about the behaviors of the program.
Within a probabilistic model of fuzzing, we show how entropy also measures
fuzzer efficiency. Specifically, it measures the general rate at which the
fuzzer discovers new behaviors. Intuitively, efficient fuzzers maximize
information.&lt;/p&gt;
&lt;p&gt;From this information theoretic perspective, we develop En- tropic, an
entropy-based power schedule for greybox fuzzing which assigns more energy to
seeds that maximize information. We implemented Entropic into the popular
greybox fuzzer LibFuzzer. Our experiments with more than 250 open-source
programs (60 million LoC) demonstrate a substantially improved efficiency and
confirm our hypothesis that an efficient fuzzer maximizes informa- tion.
Entropic has been independently evaluated and invited for integration into
main-line LibFuzzer. Entropic will run on more than 25,000 machines fuzzing
hundreds of security-critical software systems simultaneously and
continuously.&lt;/p&gt;
&lt;style type=&#34;text/css&#34;&gt;
body{ /* Normal  */
    font-size: 13pt;
}
&lt;/style&gt;
</description>
    </item>
    
    <item>
      <title>Ankou: Guiding Grey-box Fuzzing towards Combinatorial Difference</title>
      <link>/publication/ankou/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      <guid>/publication/ankou/</guid>
      <description>&lt;style type=&#34;text/css&#34;&gt;
body{ /* Normal  */
    font-size: 13pt;
}
&lt;/style&gt;
</description>
    </item>
    
    <item>
      <title>The Art, Science, and Engineering of Fuzzing: A Survey</title>
      <link>/publication/survey/</link>
      <pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/publication/survey/</guid>
      <description>&lt;p&gt;Among the many software testing techniques available today, &lt;em&gt;fuzzing&lt;/em&gt; has
remained highly popular due to its conceptual simplicity, its low barrier to
deployment, and its vast amount of empirical evidence in discovering real-world
software vulnerabilities.
At a high level, fuzzing refers to a process of repeatedly running a program
with generated inputs that may be syntactically or semantically malformed.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://ieeexplore.ieee.org/document/8863940&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Our survey&lt;/a&gt; shows the fuzzing
community is extremely vibrant.
The recent surge of work by researchers and practitioners alike has made it
difficult to gain a comprehensive and coherent view of fuzzing. Thus, it is easy
to lose track of the design decisions and potentially important tweaks performed
in each tool and paper.
Furthermore, there has been an observable fragmentation in the terminology used
by various fuzzers. For example, test case &amp;ldquo;minimization&amp;rdquo; and &amp;ldquo;reduction&amp;rdquo;
are often used interchangeably. Such fragmentation makes it difficult to
discover and disseminate knowledge and may severely hinder the progress in
fuzzing research in the long run.&lt;/p&gt;
&lt;p&gt;To help preserve and bring coherence to the vast literature of fuzzing, this
paper presented a unified, general-purpose model of fuzzing together with a
taxonomy of the current literature.
Our terminology is chosen to closely reflect the current predominant usages, and
our model is designed to suit a large number of fuzzing tasks.
We surveyed academic papers from the major Security and Software Engineering
conferences in the last 10 years, as well as projects having more than 100 stars
on GitHub.
The paper methodically explores the design decisions at every stage of the model
by surveying the related literature and innovations that make modern-day fuzzers
effective.&lt;/p&gt;
&lt;h2 id=&#34;companion-website&#34;&gt;Companion Website&lt;/h2&gt;
&lt;p&gt;Our contribution in this work is more than just the survey. Upon receiving the
acceptance notice, we have started building 
&lt;a href=&#34;https://fuzzing-survey.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;a companion
website&lt;/a&gt;. It is backed by 
&lt;a href=&#34;https://github.com/SoftSec-KAIST/Fuzzing-Survey&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;a repository at
GitHub&lt;/a&gt;, which contains the
genealogy and the classification data of the surveyed fuzzers in the JSON
format. We plan to keep this site up-to-date periodically through investing our
own effort and accepting contributions from the community.&lt;/p&gt;
&lt;style type=&#34;text/css&#34;&gt;
body{ /* Normal  */
    font-size: 13pt;
}
&lt;/style&gt;
</description>
    </item>
    
    <item>
      <title>Compiling Linux Kernel with Clang</title>
      <link>/post/kernel_clang_compile/</link>
      <pubDate>Sat, 13 Jan 2018 00:00:00 +0000</pubDate>
      <guid>/post/kernel_clang_compile/</guid>
      <description>&lt;p&gt;Hi everyone. This is my first &amp;lsquo;technical&amp;rsquo; blog post. I saw some people saying it
helps growing your explanation skills which I sincerely lack. Thus, I decided
next I struggle doing something because I feel it&amp;rsquo;s quite undocumented, I&amp;rsquo;ll try
to make a post and explain how I did it. If even one person reads this and it&amp;rsquo;s
even remotely useful to them, I&amp;rsquo;ll consider the job done. Ask any question, I&amp;rsquo;ll
be happy to answer.&lt;/p&gt;
&lt;p&gt;Now down to the topic. I have trying to compile the kernel with clang ever since
I have seen the 
&lt;a href=&#34;https://lwn.net/Articles/734071/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LWN.net article&lt;/a&gt; on the
topic. It says that you &amp;lsquo;just&amp;rsquo; need to go and compile your kernel with &lt;code&gt;make CC=clang&lt;/code&gt;. So I went into the linux sources I had at this time (something around
4.9.60) and type the command. Obviously it didn&amp;rsquo;t work.&lt;/p&gt;
&lt;p&gt;Turns out, it&amp;rsquo;s not that much complicated. There are two requirements to
compiling your kernel with clang:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Get the right source and configuration.&lt;/li&gt;
&lt;li&gt;Get the right version of clang.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Everything is very well summarized on a LKML post from last November:
&lt;a href=&#34;https://lkml.org/lkml/2017/11/22/943&#34;&gt;https://lkml.org/lkml/2017/11/22/943&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Concerning the source, I went for the simplest path: getting the latest stable
version of the kernel with default configuration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git
cd linux-stable
git checkout v4.14.15
make defconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here I&amp;rsquo;m on x86. If you want to compile for ARM64, it seems a bit more
complicated. I didn&amp;rsquo;t try it but you might want to look for the android source
that have not been upstreamed yet. Posting here because it&amp;rsquo;s not linked in the
Matthias Kaehlcke&amp;rsquo;s LKML post:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://android.googlesource.com/kernel/common.git/+log/android-4.9&#34;&gt;https://android.googlesource.com/kernel/common.git/+log/android-4.9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://android.googlesource.com/kernel/common.git/+log/android-4.4&#34;&gt;https://android.googlesource.com/kernel/common.git/+log/android-4.4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There also other documentation made by Google 
&lt;a href=&#34;https://apt.llvm.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;
which shows how to compile the kernel with KASAN and KCOV. Didn&amp;rsquo;t dig into that
but could be useful to someone.&lt;/p&gt;
&lt;p&gt;If you are looking for other configuration than just the default one, I didn&amp;rsquo;t
try that and I think it&amp;rsquo;s really and a case by case basis. You are going to have
to dig a little bit more.&lt;/p&gt;
&lt;p&gt;And for the version of clang, you need clang 5 or more. I on Debian Stretch for
which LLVM has precompiled binary (see here if you are on another OS version).
So add them to your source list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo vim /etc/apt/sources.list 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then add:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deb http://apt.llvm.org/stretch/ llvm-toolchain-stretch-6.0 main
deb-src http://apt.llvm.org/stretch/ llvm-toolchain-stretch-6.0 main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you can install clang:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get update
sudo apt-get install clang-6.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are not on Debian/Ubuntu, I am not sure whether or not there is another
solution than just compiling LLVM directly (see 
&lt;a href=&#34;https://clang.llvm.org/get_started.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Finally, we have the source and the compiler, so we are ready to compile. Go in
your linux-stable/ folder and:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make CC=clang-6.0 -j4 bzImage
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I just wanted the &lt;code&gt;bzImage&lt;/code&gt; to boot, but you remove it if you want to compile
everything.
&lt;code&gt;-j4&lt;/code&gt; because gain time by making compilation parallel&amp;hellip; Now I don&amp;rsquo;t know how you
plan to use your clang compiled kernel, but just to check it&amp;rsquo;s usable, I run it
with qemu:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;qemu-system-x86_64 -kernel arch/x86/boot/bzImage -nographic -serial mon:stdio -append &#39;console=ttyS0&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And since we didn&amp;rsquo;t provide the -initrd option, it will crash at the end with
something like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are plenty of guides on how to use your kernel, not the goal here.&lt;/p&gt;
&lt;p&gt;That will conclude my first post. Hopefully it was clear enough. Don&amp;rsquo;t hesitate
to contact me by any mean if you have any question or problems.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Domain Isolated Kernel: A lightweight sandbox for untrusted kernel extensions</title>
      <link>/publication/dikernel/</link>
      <pubDate>Tue, 02 Jan 2018 00:00:00 +0000</pubDate>
      <guid>/publication/dikernel/</guid>
      <description>&lt;style type=&#34;text/css&#34;&gt;
body{ /* Normal  */
    font-size: 13pt;
}
&lt;/style&gt;
</description>
    </item>
    
  </channel>
</rss>
